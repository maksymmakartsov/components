{"version":3,"file":"grid-key-manager.js","sourceRoot":"","sources":["../../../../src/material-experimental/mdc-chips/grid-key-manager.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,SAAS,EAAC,MAAM,eAAe,CAAC;AACxC,OAAO,EAAC,OAAO,EAAC,MAAM,MAAM,CAAC;AAC7B,OAAO,EACL,QAAQ,EACR,UAAU,EACV,UAAU,EACV,WAAW,GACZ,MAAM,uBAAuB,CAAC;;;;;AAI/B,MAAM,OAAO,eAAe,GAAG,CAAC,UAAU,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU,CAAC;;;;;;AAG9E,uCAEC;;;IADC,kCAAW;;;;;;;;;;AAUb,MAAM,OAAO,cAAc;;;;IAOzB,YAAoB,KAA+D;QAA/D,UAAK,GAAL,KAAK,CAA0D;QAN3E,oBAAe,GAAG,CAAC,CAAC,CAAC;QACrB,uBAAkB,GAAG,CAAC,CAAC,CAAC;QACxB,eAAU,GAAgC,IAAI,CAAC;QAC/C,gBAAW,GAAa,IAAI,CAAC;QAC7B,SAAI,GAAkB,KAAK,CAAC;;;;QAoBpC,WAAM,GAAG,IAAI,OAAO,EAAiC,CAAC;QAjBpD,gFAAgF;QAChF,gFAAgF;QAChF,wEAAwE;QACxE,IAAI,KAAK,YAAY,SAAS,EAAE;YAC9B,KAAK,CAAC,OAAO,CAAC,SAAS;;;;YAAC,CAAC,OAAwC,EAAE,EAAE;gBACnE,IAAI,IAAI,CAAC,UAAU,EAAE;;0BACb,QAAQ,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC;oBAE3D,IAAI,QAAQ,GAAG,CAAC,CAAC,IAAI,QAAQ,KAAK,IAAI,CAAC,eAAe,EAAE;wBACtD,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC;qBACjC;iBACF;YACH,CAAC,EAAC,CAAC;SACJ;IACH,CAAC;;;;;;;;;;IAWD,kBAAkB,CAAC,SAAwB;QACzC,mBAAA,IAAI,EAAA,CAAC,IAAI,GAAG,SAAS,CAAC;QACtB,OAAO,mBAAA,IAAI,EAAA,CAAC;IACd,CAAC;;;;;IAcD,aAAa,CAAC,IAAS;;cACf,gBAAgB,GAAG,IAAI,CAAC,eAAe;;cACvC,mBAAmB,GAAG,IAAI,CAAC,kBAAkB;QAEnD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAE5B,IAAI,IAAI,CAAC,eAAe,KAAK,gBAAgB;YAC3C,IAAI,CAAC,kBAAkB,KAAK,mBAAmB,EAAE;YACjD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAC,GAAG,EAAE,IAAI,CAAC,eAAe,EAAE,MAAM,EAAE,IAAI,CAAC,kBAAkB,EAAC,CAAC,CAAC;SAChF;IACH,CAAC;;;;;;IAMD,SAAS,CAAC,KAAoB;;cACtB,OAAO,GAAG,KAAK,CAAC,OAAO;QAE7B,QAAQ,OAAO,EAAE;YACf,KAAK,UAAU;gBACb,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACxB,MAAM;YAER,KAAK,QAAQ;gBACX,IAAI,CAAC,oBAAoB,EAAE,CAAC;gBAC5B,MAAM;YAER,KAAK,WAAW;gBACd,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAClF,MAAM;YAER,KAAK,UAAU;gBACb,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC;gBAClF,MAAM;YAER;gBACE,yDAAyD;gBACzD,+CAA+C;gBAC/C,OAAO;SACV;QAED,KAAK,CAAC,cAAc,EAAE,CAAC;IACzB,CAAC;;;;;IAGD,IAAI,cAAc;QAChB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;;;;;IAGD,IAAI,iBAAiB;QACnB,OAAO,IAAI,CAAC,kBAAkB,CAAC;IACjC,CAAC;;;;;IAGD,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;;;;;IAGD,kBAAkB;QAChB,IAAI,CAAC,qBAAqB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnC,CAAC;;;;;IAGD,iBAAiB;;cACT,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC;;cACpC,OAAO,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC,YAAY,CAAC;QAClD,IAAI,CAAC,qBAAqB,CAAC,YAAY,EAAE,OAAO,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACrE,CAAC;;;;;IAGD,gBAAgB;QACd,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1F,CAAC;;;;;IAGD,oBAAoB;QAClB,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACpC,CAAC;;;;;;IAMD,mBAAmB;QACjB,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1F,CAAC;;;;;;IAMD,uBAAuB;QACrB,IAAI,CAAC,qBAAqB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACpC,CAAC;;;;;IAcD,gBAAgB,CAAC,IAAS;;cAClB,QAAQ,GAAG,IAAI,CAAC,aAAa,EAAE;QAErC,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,GAAG,KAAK,QAAQ;YAC1D,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,EAAE;YACjC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC;YAChC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,MAAM,CAAC;YACtC,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC;YAC7C,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;SACxF;aAAM;YACL,QAAQ,CAAC,OAAO;;;;;YAAC,CAAC,GAAG,EAAE,QAAQ,EAAE,EAAE;;sBAC3B,WAAW,GAAG,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;gBAC3C,IAAI,WAAW,KAAK,CAAC,CAAC,EAAE;oBACtB,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC;oBAChC,IAAI,CAAC,kBAAkB,GAAG,WAAW,CAAC;oBACtC,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC;oBACtB,IAAI,CAAC,WAAW,GAAG,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;iBAC3C;YACH,CAAC,EAAC,CAAC;SACJ;IACH,CAAC;;;;;;;;;IAMO,qBAAqB,CAAC,QAAoB,EAAE,WAAuB;QACzE,wFAAwF;QACxF,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,kBAAkB,GAAG,WAAW,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,EAAE;YAC5F,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,eAAe,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;YAE1D,gGAAgG;SAC/F;aAAM,IAAI,IAAI,CAAC,kBAAkB,GAAG,WAAW,GAAG,CAAC,EAAE;;kBAC9C,gBAAgB,GAAG,IAAI,CAAC,eAAe,GAAG,CAAC;;kBAC3C,WAAW,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC,gBAAgB,CAAC;YAC1D,IAAI,WAAW,EAAE;gBACf,IAAI,CAAC,qBAAqB,CAAC,gBAAgB,EAAE,WAAW,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;aAC5E;SACF;aAAM;YACL,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,eAAe,GAAG,QAAQ,EACxD,IAAI,CAAC,kBAAkB,GAAG,WAAW,CAAC,CAAC;SAC1C;IACH,CAAC;;;;;;;;IAKO,qBAAqB,CAAC,QAAgB,EAAE,WAAmB;;cAC3D,IAAI,GAAG,IAAI,CAAC,aAAa,EAAE;;cAE3B,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC;QAEhC,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;YAC/C,OAAO;SACR;QAED,IAAI,CAAC,aAAa,CAAC,EAAC,GAAG,EAAE,QAAQ,EAAE,MAAM,EAAE,WAAW,EAAC,CAAC,CAAC;IAC3D,CAAC;;;;;;IAGO,aAAa;QACnB,OAAO,IAAI,CAAC,KAAK,YAAY,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;IAC7E,CAAC;CACF;;;;;;IA9NC,yCAA6B;;;;;IAC7B,4CAAgC;;;;;IAChC,oCAAuD;;;;;IACvD,qCAAqC;;;;;IACrC,8BAAoC;;;;;IAoBpC,gCAAsD;;;;;IAlB1C,+BAAuE","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {QueryList} from '@angular/core';\nimport {Subject} from 'rxjs';\nimport {\n  UP_ARROW,\n  DOWN_ARROW,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n} from '@angular/cdk/keycodes';\n\n\n/** The keys handled by the GridKeyManager keydown method. */\nexport const NAVIGATION_KEYS = [DOWN_ARROW, UP_ARROW, RIGHT_ARROW, LEFT_ARROW];\n\n/** This interface is for rows that can be passed to a GridKeyManager. */\nexport interface GridKeyManagerRow<T> {\n  cells: T[];\n}\n\n/**\n * This class manages keyboard events for grids. If you pass it a query list\n * of GridKeyManagerRow, it will set the active cell correctly when arrow events occur.\n *\n * GridKeyManager expects that rows may change dynamically, but the cells for a given row are\n * static. It also expects that all rows have the same number of cells.\n */\nexport class GridKeyManager<T> {\n  private _activeRowIndex = -1;\n  private _activeColumnIndex = -1;\n  private _activeRow: GridKeyManagerRow<T> | null = null;\n  private _activeCell: T | null = null;\n  private _dir: 'ltr' | 'rtl' = 'ltr';\n\n  constructor(private _rows: QueryList<GridKeyManagerRow<T>> | GridKeyManagerRow<T>[]) {\n    // We allow for the rows to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the rows they want to manage (e.g. when the\n    // rows aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_rows instanceof QueryList) {\n      _rows.changes.subscribe((newRows: QueryList<GridKeyManagerRow<T>>) => {\n        if (this._activeRow) {\n          const newIndex = newRows.toArray().indexOf(this._activeRow);\n\n          if (newIndex > -1 && newIndex !== this._activeRowIndex) {\n            this._activeRowIndex = newIndex;\n          }\n        }\n      });\n    }\n  }\n\n  /** Stream that emits whenever the active cell of the grid manager changes. */\n  change = new Subject<{row: number, column: number}>();\n\n  /**\n   * Configures the directionality of the key manager's horizontal movement.\n   * @param direction Direction which is considered forward movement across a row.\n   *\n   * If withDirectionality is not set, the default is 'ltr'.\n   */\n  withDirectionality(direction: 'ltr' | 'rtl'): this {\n    this._dir = direction;\n    return this;\n  }\n\n  /**\n   * Sets the active cell to the cell at the indices specified.\n   * @param cell The row and column containing the cell to be set as active.\n   */\n  setActiveCell(cell: {row: number, column: number}): void;\n\n  /**\n   * Sets the active cell to the cell.\n   * @param cell The cell to be set as active.\n   */\n  setActiveCell(cell: T): void;\n\n  setActiveCell(cell: any): void {\n    const previousRowIndex = this._activeRowIndex;\n    const previousColumnIndex = this._activeColumnIndex;\n\n    this.updateActiveCell(cell);\n\n    if (this._activeRowIndex !== previousRowIndex ||\n      this._activeColumnIndex !== previousColumnIndex) {\n      this.change.next({row: this._activeRowIndex, column: this._activeColumnIndex});\n    }\n  }\n\n  /**\n   * Sets the active cell depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n\n    switch (keyCode) {\n      case DOWN_ARROW:\n        this.setNextRowActive();\n        break;\n\n      case UP_ARROW:\n        this.setPreviousRowActive();\n        break;\n\n      case RIGHT_ARROW:\n        this._dir === 'rtl' ? this.setPreviousColumnActive() : this.setNextColumnActive();\n        break;\n\n      case LEFT_ARROW:\n        this._dir === 'rtl' ? this.setNextColumnActive() : this.setPreviousColumnActive();\n        break;\n\n      default:\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n\n    event.preventDefault();\n  }\n\n  /** Index of the currently active row. */\n  get activeRowIndex(): number {\n    return this._activeRowIndex;\n  }\n\n  /** Index of the currently active column. */\n  get activeColumnIndex(): number {\n    return this._activeColumnIndex;\n  }\n\n  /** The active cell. */\n  get activeCell(): T | null {\n    return this._activeCell;\n  }\n\n  /** Sets the active cell to the first cell in the grid. */\n  setFirstCellActive(): void {\n    this._setActiveCellByIndex(0, 0);\n  }\n\n  /** Sets the active cell to the last cell in the grid. */\n  setLastCellActive(): void {\n    const lastRowIndex = this._rows.length - 1;\n    const lastRow = this._getRowsArray()[lastRowIndex];\n    this._setActiveCellByIndex(lastRowIndex, lastRow.cells.length - 1);\n  }\n\n  /** Sets the active row to the next row in the grid. Active column is unchanged. */\n  setNextRowActive(): void {\n    this._activeRowIndex < 0 ? this.setFirstCellActive() : this._setActiveCellByDelta(1, 0);\n  }\n\n  /** Sets the active row to the previous row in the grid. Active column is unchanged. */\n  setPreviousRowActive(): void {\n    this._setActiveCellByDelta(-1, 0);\n  }\n\n  /**\n   * Sets the active column to the next column in the grid.\n   * Active row is unchanged, unless we reach the end of a row.\n   */\n  setNextColumnActive(): void {\n    this._activeRowIndex < 0 ? this.setFirstCellActive() : this._setActiveCellByDelta(0, 1);\n  }\n\n  /**\n   * Sets the active column to the previous column in the grid.\n   * Active row is unchanged, unless we reach the end of a row.\n   */\n  setPreviousColumnActive(): void {\n    this._setActiveCellByDelta(0, -1);\n  }\n\n  /**\n   * Allows setting the active cell without any other effects.\n   * @param cell Row and column of the cell to be set as active.\n   */\n  updateActiveCell(cell: {row: number, column: number}): void;\n\n  /**\n   * Allows setting the active cell without any other effects.\n   * @param cell Cell to be set as active.\n   */\n  updateActiveCell(cell: T): void;\n\n  updateActiveCell(cell: any): void {\n    const rowArray = this._getRowsArray();\n\n    if (typeof cell === 'object' && typeof cell.row === 'number' &&\n      typeof cell.column === 'number') {\n      this._activeRowIndex = cell.row;\n      this._activeColumnIndex = cell.column;\n      this._activeRow = rowArray[cell.row] || null;\n      this._activeCell = this._activeRow ? this._activeRow.cells[cell.column] || null : null;\n    } else {\n      rowArray.forEach((row, rowIndex) => {\n        const columnIndex = row.cells.indexOf(cell);\n        if (columnIndex !== -1) {\n          this._activeRowIndex = rowIndex;\n          this._activeColumnIndex = columnIndex;\n          this._activeRow = row;\n          this._activeCell = row.cells[columnIndex];\n        }\n      });\n    }\n  }\n\n  /**\n   * This method sets the active cell, given the row and columns deltas\n   * between the currently active cell and the new active cell.\n   */\n  private _setActiveCellByDelta(rowDelta: -1 | 0 | 1, columnDelta: -1 | 0 | 1): void {\n    // If delta puts us past the last cell in a row, move to the first cell of the next row.\n    if (this._activeRow && this._activeColumnIndex + columnDelta >= this._activeRow.cells.length) {\n      this._setActiveCellByIndex(this._activeRowIndex + 1, 0);\n\n    // If delta puts us prior to the first cell in a row, move to the last cell of the previous row.\n    } else if (this._activeColumnIndex + columnDelta < 0) {\n      const previousRowIndex = this._activeRowIndex - 1;\n      const previousRow = this._getRowsArray()[previousRowIndex];\n      if (previousRow) {\n        this._setActiveCellByIndex(previousRowIndex, previousRow.cells.length - 1);\n      }\n    } else {\n      this._setActiveCellByIndex(this._activeRowIndex + rowDelta,\n        this._activeColumnIndex + columnDelta);\n    }\n  }\n\n  /**\n   * Sets the active cell to the cell at the indices specified, if they are valid.\n   */\n  private _setActiveCellByIndex(rowIndex: number, columnIndex: number): void {\n    const rows = this._getRowsArray();\n\n    const targetRow = rows[rowIndex];\n\n    if (!targetRow || !targetRow.cells[columnIndex]) {\n      return;\n    }\n\n    this.setActiveCell({row: rowIndex, column: columnIndex});\n  }\n\n  /** Returns the rows as an array. */\n  private _getRowsArray(): GridKeyManagerRow<T>[] {\n    return this._rows instanceof QueryList ? this._rows.toArray() : this._rows;\n  }\n}\n"]}
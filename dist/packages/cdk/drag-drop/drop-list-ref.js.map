{"version":3,"file":"drop-list-ref.js","sourceRoot":"","sources":["../../../../src/cdk/drag-drop/drop-list-ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ElementRef, NgZone} from '@angular/core';\nimport {Direction} from '@angular/cdk/bidi';\nimport {coerceElement} from '@angular/cdk/coercion';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {_supportsShadowDom} from '@angular/cdk/platform';\nimport {Subject, Subscription, interval, animationFrameScheduler} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {moveItemInArray} from './drag-utils';\nimport {DragDropRegistry} from './drag-drop-registry';\nimport {DragRefInternal as DragRef, Point} from './drag-ref';\n\n/** Counter used to generate unique ids for drop refs. */\nlet _uniqueIdCounter = 0;\n\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling the drop list or the\n * viewport. The value comes from trying it out manually until it feels right.\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n\n/**\n * Number of pixels to scroll for each frame when auto-scrolling an element.\n * The value comes from trying it out manually until it feels right.\n */\nconst AUTO_SCROLL_STEP = 2;\n\n/**\n * Entry in the position cache for draggable items.\n * @docs-private\n */\ninterface CachedItemPosition {\n  /** Instance of the drag item. */\n  drag: DragRef;\n  /** Dimensions of the item. */\n  clientRect: ClientRect;\n  /** Amount by which the item has been moved since dragging started. */\n  offset: number;\n}\n\n/** Object holding the scroll position of something. */\ninterface ScrollPosition {\n  top: number;\n  left: number;\n}\n\n/** Vertical direction in which we can auto-scroll. */\nconst enum AutoScrollVerticalDirection {NONE, UP, DOWN}\n\n/** Horizontal direction in which we can auto-scroll. */\nconst enum AutoScrollHorizontalDirection {NONE, LEFT, RIGHT}\n\n/**\n * Internal compile-time-only representation of a `DropListRef`.\n * Used to avoid circular import issues between the `DropListRef` and the `DragRef`.\n * @docs-private\n */\nexport interface DropListRefInternal extends DropListRef {}\n\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * @docs-private\n */\nexport class DropListRef<T = any> {\n  /** Element that the drop list is attached to. */\n  element: HTMLElement | ElementRef<HTMLElement>;\n\n  /**\n   * Unique ID for the drop list.\n   * @deprecated No longer being used. To be removed.\n   * @breaking-change 8.0.0\n   */\n  id = `cdk-drop-list-ref-${_uniqueIdCounter++}`;\n\n  /** Whether starting a dragging sequence from this container is disabled. */\n  disabled: boolean = false;\n\n  /** Whether sorting items within the list is disabled. */\n  sortingDisabled: boolean = false;\n\n  /** Locks the position of the draggable elements inside the container along the specified axis. */\n  lockAxis: 'x' | 'y';\n\n  /**\n   * Whether auto-scrolling the view when the user\n   * moves their pointer close to the edges is disabled.\n   */\n  autoScrollDisabled: boolean = false;\n\n  /**\n   * Function that is used to determine whether an item\n   * is allowed to be moved into a drop container.\n   */\n  enterPredicate: (drag: DragRef, drop: DropListRef) => boolean = () => true;\n\n  /** Emits right before dragging has started. */\n  beforeStarted = new Subject<void>();\n\n  /**\n   * Emits when the user has moved a new drag item into this container.\n   */\n  entered = new Subject<{item: DragRef, container: DropListRef, currentIndex: number}>();\n\n  /**\n   * Emits when the user removes an item from the container\n   * by dragging it into another container.\n   */\n  exited = new Subject<{item: DragRef, container: DropListRef}>();\n\n  /** Emits when the user drops an item inside the container. */\n  dropped = new Subject<{\n    item: DragRef,\n    currentIndex: number,\n    previousIndex: number,\n    container: DropListRef,\n    previousContainer: DropListRef,\n    isPointerOverContainer: boolean,\n    distance: Point;\n  }>();\n\n  /** Emits as the user is swapping items while actively dragging. */\n  sorted = new Subject<{\n    previousIndex: number,\n    currentIndex: number,\n    container: DropListRef,\n    item: DragRef\n  }>();\n\n  /** Arbitrary data that can be attached to the drop list. */\n  data: T;\n\n  /** Whether an item in the list is being dragged. */\n  private _isDragging = false;\n\n  /** Cache of the dimensions of all the items inside the container. */\n  private _itemPositions: CachedItemPosition[] = [];\n\n  /** Keeps track of the container's scroll position. */\n  private _scrollPosition: ScrollPosition = {top: 0, left: 0};\n\n  /** Keeps track of the scroll position of the viewport. */\n  private _viewportScrollPosition: ScrollPosition = {top: 0, left: 0};\n\n  /** Cached `ClientRect` of the drop list. */\n  private _clientRect: ClientRect;\n\n  /**\n   * Draggable items that are currently active inside the container. Includes the items\n   * from `_draggables`, as well as any items that have been dragged in, but haven't\n   * been dropped yet.\n   */\n  private _activeDraggables: DragRef[];\n\n  /**\n   * Keeps track of the item that was last swapped with the dragged item, as\n   * well as what direction the pointer was moving in when the swap occured.\n   */\n  private _previousSwap = {drag: null as DragRef | null, delta: 0};\n\n  /** Draggable items in the container. */\n  private _draggables: ReadonlyArray<DragRef>;\n\n  /** Drop lists that are connected to the current one. */\n  private _siblings: ReadonlyArray<DropListRef> = [];\n\n  /** Direction in which the list is oriented. */\n  private _orientation: 'horizontal' | 'vertical' = 'vertical';\n\n  /** Connected siblings that currently have a dragged item. */\n  private _activeSiblings = new Set<DropListRef>();\n\n  /** Layout direction of the drop list. */\n  private _direction: Direction = 'ltr';\n\n  /** Subscription to the window being scrolled. */\n  private _viewportScrollSubscription = Subscription.EMPTY;\n\n  /** Vertical direction in which the list is currently scrolling. */\n  private _verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n\n  /** Horizontal direction in which the list is currently scrolling. */\n  private _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n\n  /** Node that is being auto-scrolled. */\n  private _scrollNode: HTMLElement | Window;\n\n  /** Used to signal to the current auto-scroll sequence when to stop. */\n  private _stopScrollTimers = new Subject<void>();\n\n  /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */\n  private _shadowRoot: DocumentOrShadowRoot;\n\n  constructor(\n    element: ElementRef<HTMLElement> | HTMLElement,\n    private _dragDropRegistry: DragDropRegistry<DragRef, DropListRef>,\n    _document: any,\n    /**\n     * @deprecated _ngZone and _viewportRuler parameters to be made required.\n     * @breaking-change 9.0.0\n     */\n    private _ngZone?: NgZone,\n    private _viewportRuler?: ViewportRuler) {\n    const nativeNode = this.element = coerceElement(element);\n    this._shadowRoot = getShadowRoot(nativeNode) || _document;\n    _dragDropRegistry.registerDropContainer(this);\n  }\n\n  /** Removes the drop list functionality from the DOM element. */\n  dispose() {\n    this._stopScrolling();\n    this._stopScrollTimers.complete();\n    this._removeListeners();\n    this.beforeStarted.complete();\n    this.entered.complete();\n    this.exited.complete();\n    this.dropped.complete();\n    this.sorted.complete();\n    this._activeSiblings.clear();\n    this._scrollNode = null!;\n    this._dragDropRegistry.removeDropContainer(this);\n  }\n\n  /** Whether an item from this list is currently being dragged. */\n  isDragging() {\n    return this._isDragging;\n  }\n\n  /** Starts dragging an item. */\n  start(): void {\n    const element = coerceElement(this.element);\n    this.beforeStarted.next();\n    this._isDragging = true;\n    this._cacheItems();\n    this._siblings.forEach(sibling => sibling._startReceiving(this));\n    this._removeListeners();\n\n    // @breaking-change 9.0.0 Remove check for _ngZone once it's marked as a required param.\n    if (this._ngZone) {\n      this._ngZone.runOutsideAngular(() => element.addEventListener('scroll', this._handleScroll));\n    } else {\n      element.addEventListener('scroll', this._handleScroll);\n    }\n\n    // @breaking-change 9.0.0 Remove check for _viewportRuler once it's marked as a required param.\n    if (this._viewportRuler) {\n      this._listenToScrollEvents();\n    }\n  }\n\n  /**\n   * Emits an event to indicate that the user moved an item into the container.\n   * @param item Item that was moved into the container.\n   * @param pointerX Position of the item along the X axis.\n   * @param pointerY Position of the item along the Y axis.\n   */\n  enter(item: DragRef, pointerX: number, pointerY: number): void {\n    this.start();\n\n    // If sorting is disabled, we want the item to return to its starting\n    // position if the user is returning it to its initial container.\n    let newIndex = this.sortingDisabled ? this._draggables.indexOf(item) : -1;\n\n    if (newIndex === -1) {\n      // We use the coordinates of where the item entered the drop\n      // zone to figure out at which index it should be inserted.\n      newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n    }\n\n    const activeDraggables = this._activeDraggables;\n    const currentIndex = activeDraggables.indexOf(item);\n    const placeholder = item.getPlaceholderElement();\n    let newPositionReference: DragRef | undefined = activeDraggables[newIndex];\n\n    // If the item at the new position is the same as the item that is being dragged,\n    // it means that we're trying to restore the item to its initial position. In this\n    // case we should use the next item from the list as the reference.\n    if (newPositionReference === item) {\n      newPositionReference = activeDraggables[newIndex + 1];\n    }\n\n    // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n    // into another container and back again), we have to ensure that it isn't duplicated.\n    if (currentIndex > -1) {\n      activeDraggables.splice(currentIndex, 1);\n    }\n\n    // Don't use items that are being dragged as a reference, because\n    // their element has been moved down to the bottom of the body.\n    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n      const element = newPositionReference.getRootElement();\n      element.parentElement!.insertBefore(placeholder, element);\n      activeDraggables.splice(newIndex, 0, item);\n    } else {\n      coerceElement(this.element).appendChild(placeholder);\n      activeDraggables.push(item);\n    }\n\n    // The transform needs to be cleared so it doesn't throw off the measurements.\n    placeholder.style.transform = '';\n\n    // Note that the positions were already cached when we called `start` above,\n    // but we need to refresh them since the amount of items has changed.\n    this._cacheItemPositions();\n    this.entered.next({item, container: this, currentIndex: this.getItemIndex(item)});\n  }\n\n  /**\n   * Removes an item from the container after it was dragged into another container by the user.\n   * @param item Item that was dragged out.\n   */\n  exit(item: DragRef): void {\n    this._reset();\n    this.exited.next({item, container: this});\n  }\n\n  /**\n   * Drops an item into this container.\n   * @param item Item being dropped into the container.\n   * @param currentIndex Index at which the item should be inserted.\n   * @param previousContainer Container from which the item got dragged in.\n   * @param isPointerOverContainer Whether the user's pointer was over the\n   *    container when the item was dropped.\n   * @param distance Distance the user has dragged since the start of the dragging sequence.\n   * @breaking-change 9.0.0 `distance` parameter to become required.\n   */\n  drop(item: DragRef, currentIndex: number, previousContainer: DropListRef,\n    isPointerOverContainer: boolean, distance: Point = {x: 0, y: 0}): void {\n    this._reset();\n    this.dropped.next({\n      item,\n      currentIndex,\n      previousIndex: previousContainer.getItemIndex(item),\n      container: this,\n      previousContainer,\n      isPointerOverContainer,\n      distance\n    });\n  }\n\n  /**\n   * Sets the draggable items that are a part of this list.\n   * @param items Items that are a part of this list.\n   */\n  withItems(items: DragRef[]): this {\n    this._draggables = items;\n    items.forEach(item => item._withDropContainer(this));\n\n    if (this.isDragging()) {\n      this._cacheItems();\n    }\n\n    return this;\n  }\n\n  /** Sets the layout direction of the drop list. */\n  withDirection(direction: Direction): this {\n    this._direction = direction;\n    return this;\n  }\n\n  /**\n   * Sets the containers that are connected to this one. When two or more containers are\n   * connected, the user will be allowed to transfer items between them.\n   * @param connectedTo Other containers that the current containers should be connected to.\n   */\n  connectedTo(connectedTo: DropListRef[]): this {\n    this._siblings = connectedTo.slice();\n    return this;\n  }\n\n  /**\n   * Sets the orientation of the container.\n   * @param orientation New orientation for the container.\n   */\n  withOrientation(orientation: 'vertical' | 'horizontal'): this {\n    this._orientation = orientation;\n    return this;\n  }\n\n  /**\n   * Figures out the index of an item in the container.\n   * @param item Item whose index should be determined.\n   */\n  getItemIndex(item: DragRef): number {\n    if (!this._isDragging) {\n      return this._draggables.indexOf(item);\n    }\n\n    // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n    // The rest of the logic still stands no matter what orientation we're in, however\n    // we need to invert the array when determining the index.\n    const items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n        this._itemPositions.slice().reverse() : this._itemPositions;\n\n    return findIndex(items, currentItem => currentItem.drag === item);\n  }\n\n  /**\n   * Whether the list is able to receive the item that\n   * is currently being dragged inside a connected drop list.\n   */\n  isReceiving(): boolean {\n    return this._activeSiblings.size > 0;\n  }\n\n  /**\n   * Sorts an item inside the container based on its position.\n   * @param item Item to be sorted.\n   * @param pointerX Position of the item along the X axis.\n   * @param pointerY Position of the item along the Y axis.\n   * @param pointerDelta Direction in which the pointer is moving along each axis.\n   */\n  _sortItem(item: DragRef, pointerX: number, pointerY: number,\n            pointerDelta: {x: number, y: number}): void {\n    // Don't sort the item if sorting is disabled or it's out of range.\n    if (this.sortingDisabled || !this._isPointerNearDropContainer(pointerX, pointerY)) {\n      return;\n    }\n\n    const siblings = this._itemPositions;\n    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n\n    if (newIndex === -1 && siblings.length > 0) {\n      return;\n    }\n\n    const isHorizontal = this._orientation === 'horizontal';\n    const currentIndex = findIndex(siblings, currentItem => currentItem.drag === item);\n    const siblingAtNewPosition = siblings[newIndex];\n    const currentPosition = siblings[currentIndex].clientRect;\n    const newPosition = siblingAtNewPosition.clientRect;\n    const delta = currentIndex > newIndex ? 1 : -1;\n\n    this._previousSwap.drag = siblingAtNewPosition.drag;\n    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n\n    // How many pixels the item's placeholder should be offset.\n    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n\n    // How many pixels all the other items should be offset.\n    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n\n    // Save the previous order of the items before moving the item to its new index.\n    // We use this to check whether an item has been moved as a result of the sorting.\n    const oldOrder = siblings.slice();\n\n    // Shuffle the array in place.\n    moveItemInArray(siblings, currentIndex, newIndex);\n\n    this.sorted.next({\n      previousIndex: currentIndex,\n      currentIndex: newIndex,\n      container: this,\n      item\n    });\n\n    siblings.forEach((sibling, index) => {\n      // Don't do anything if the position hasn't changed.\n      if (oldOrder[index] === sibling) {\n        return;\n      }\n\n      const isDraggedItem = sibling.drag === item;\n      const offset = isDraggedItem ? itemOffset : siblingOffset;\n      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                                              sibling.drag.getRootElement();\n\n      // Update the offset to reflect the new position.\n      sibling.offset += offset;\n\n      // Since we're moving the items with a `transform`, we need to adjust their cached\n      // client rects to reflect their new position, as well as swap their positions in the cache.\n      // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n      // elements may be mid-animation which will give us a wrong result.\n      if (isHorizontal) {\n        // Round the transforms since some browsers will\n        // blur the elements, for sub-pixel transforms.\n        elementToOffset.style.transform = `translate3d(${Math.round(sibling.offset)}px, 0, 0)`;\n        adjustClientRect(sibling.clientRect, 0, offset);\n      } else {\n        elementToOffset.style.transform = `translate3d(0, ${Math.round(sibling.offset)}px, 0)`;\n        adjustClientRect(sibling.clientRect, offset, 0);\n      }\n    });\n  }\n\n  /**\n   * Checks whether the user's pointer is close to the edges of either the\n   * viewport or the drop list and starts the auto-scroll sequence.\n   * @param pointerX User's pointer position along the x axis.\n   * @param pointerY User's pointer position along the y axis.\n   */\n  _startScrollingIfNecessary(pointerX: number, pointerY: number) {\n    if (this.autoScrollDisabled) {\n      return;\n    }\n\n    let scrollNode: HTMLElement | Window | undefined;\n    let verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n    let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n\n    // Check whether we should start scrolling the container.\n    if (this._isPointerNearDropContainer(pointerX, pointerY)) {\n      const element = coerceElement(this.element);\n\n      [verticalScrollDirection, horizontalScrollDirection] =\n          getElementScrollDirections(element, this._clientRect, pointerX, pointerY);\n\n      if (verticalScrollDirection || horizontalScrollDirection) {\n        scrollNode = element;\n      }\n    }\n\n    // @breaking-change 9.0.0 Remove null check for _viewportRuler once it's a required parameter.\n    // Otherwise check if we can start scrolling the viewport.\n    if (this._viewportRuler && !verticalScrollDirection && !horizontalScrollDirection) {\n      const {width, height} = this._viewportRuler.getViewportSize();\n      const clientRect = {width, height, top: 0, right: width, bottom: height, left: 0};\n      verticalScrollDirection = getVerticalScrollDirection(clientRect, pointerY);\n      horizontalScrollDirection = getHorizontalScrollDirection(clientRect, pointerX);\n      scrollNode = window;\n    }\n\n    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection ||\n        horizontalScrollDirection !== this._horizontalScrollDirection ||\n        scrollNode !== this._scrollNode)) {\n      this._verticalScrollDirection = verticalScrollDirection;\n      this._horizontalScrollDirection = horizontalScrollDirection;\n      this._scrollNode = scrollNode;\n\n      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n        // @breaking-change 9.0.0 Remove null check for `_ngZone` once it is made required.\n        if (this._ngZone) {\n          this._ngZone.runOutsideAngular(this._startScrollInterval);\n        } else {\n          this._startScrollInterval();\n        }\n      } else {\n        this._stopScrolling();\n      }\n    }\n  }\n\n  /** Stops any currently-running auto-scroll sequences. */\n  _stopScrolling() {\n    this._stopScrollTimers.next();\n  }\n\n  /** Caches the position of the drop list. */\n  private _cacheOwnPosition() {\n    const element = coerceElement(this.element);\n    this._clientRect = getMutableClientRect(element);\n    this._scrollPosition = {top: element.scrollTop, left: element.scrollLeft};\n  }\n\n  /** Refreshes the position cache of the items and sibling containers. */\n  private _cacheItemPositions() {\n    const isHorizontal = this._orientation === 'horizontal';\n\n    this._itemPositions = this._activeDraggables.map(drag => {\n      const elementToMeasure = this._dragDropRegistry.isDragging(drag) ?\n          // If the element is being dragged, we have to measure the\n          // placeholder, because the element is hidden.\n          drag.getPlaceholderElement() :\n          drag.getRootElement();\n      return {drag, offset: 0, clientRect: getMutableClientRect(elementToMeasure)};\n    }).sort((a, b) => {\n      return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                            a.clientRect.top - b.clientRect.top;\n    });\n  }\n\n  /** Resets the container to its initial state. */\n  private _reset() {\n    this._isDragging = false;\n\n    // TODO(crisbeto): may have to wait for the animations to finish.\n    this._activeDraggables.forEach(item => item.getRootElement().style.transform = '');\n    this._siblings.forEach(sibling => sibling._stopReceiving(this));\n    this._activeDraggables = [];\n    this._itemPositions = [];\n    this._previousSwap.drag = null;\n    this._previousSwap.delta = 0;\n    this._stopScrolling();\n    this._removeListeners();\n  }\n\n  /**\n   * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n   * @param currentIndex Index of the item currently being dragged.\n   * @param siblings All of the items in the list.\n   * @param delta Direction in which the user is moving.\n   */\n  private _getSiblingOffsetPx(currentIndex: number,\n                              siblings: CachedItemPosition[],\n                              delta: 1 | -1) {\n\n    const isHorizontal = this._orientation === 'horizontal';\n    const currentPosition = siblings[currentIndex].clientRect;\n    const immediateSibling = siblings[currentIndex + delta * -1];\n    let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n\n    if (immediateSibling) {\n      const start = isHorizontal ? 'left' : 'top';\n      const end = isHorizontal ? 'right' : 'bottom';\n\n      // Get the spacing between the start of the current item and the end of the one immediately\n      // after it in the direction in which the user is dragging, or vice versa. We add it to the\n      // offset in order to push the element to where it will be when it's inline and is influenced\n      // by the `margin` of its siblings.\n      if (delta === -1) {\n        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n      } else {\n        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n      }\n    }\n\n    return siblingOffset;\n  }\n\n  /**\n   * Checks whether the pointer coordinates are close to the drop container.\n   * @param pointerX Coordinates along the X axis.\n   * @param pointerY Coordinates along the Y axis.\n   */\n  private _isPointerNearDropContainer(pointerX: number, pointerY: number): boolean {\n    const {top, right, bottom, left, width, height} = this._clientRect;\n    const xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n    const yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n\n    return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n           pointerX > left - xThreshold && pointerX < right + xThreshold;\n  }\n\n  /**\n   * Gets the offset in pixels by which the item that is being dragged should be moved.\n   * @param currentPosition Current position of the item.\n   * @param newPosition Position of the item where the current item should be moved.\n   * @param delta Direction in which the user is moving.\n   */\n  private _getItemOffsetPx(currentPosition: ClientRect, newPosition: ClientRect, delta: 1 | -1) {\n    const isHorizontal = this._orientation === 'horizontal';\n    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n                                    newPosition.top - currentPosition.top;\n\n    // Account for differences in the item width/height.\n    if (delta === -1) {\n      itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                                   newPosition.height - currentPosition.height;\n    }\n\n    return itemOffset;\n  }\n\n  /**\n   * Gets the index of an item in the drop container, based on the position of the user's pointer.\n   * @param item Item that is being sorted.\n   * @param pointerX Position of the user's pointer along the X axis.\n   * @param pointerY Position of the user's pointer along the Y axis.\n   * @param delta Direction in which the user is moving their pointer.\n   */\n  private _getItemIndexFromPointerPosition(item: DragRef, pointerX: number, pointerY: number,\n                                           delta?: {x: number, y: number}) {\n    const isHorizontal = this._orientation === 'horizontal';\n\n    return findIndex(this._itemPositions, ({drag, clientRect}, _, array) => {\n      if (drag === item) {\n        // If there's only one item left in the container, it must be\n        // the dragged item itself so we use it as a reference.\n        return array.length < 2;\n      }\n\n      if (delta) {\n        const direction = isHorizontal ? delta.x : delta.y;\n\n        // If the user is still hovering over the same item as last time, and they didn't change\n        // the direction in which they're dragging, we don't consider it a direction swap.\n        if (drag === this._previousSwap.drag && direction === this._previousSwap.delta) {\n          return false;\n        }\n      }\n\n      return isHorizontal ?\n          // Round these down since most browsers report client rects with\n          // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n          pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n          pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n    });\n  }\n\n  /** Caches the current items in the list and their positions. */\n  private _cacheItems(): void {\n    this._activeDraggables = this._draggables.slice();\n    this._cacheItemPositions();\n    this._cacheOwnPosition();\n  }\n\n  /**\n   * Updates the internal state of the container after a scroll event has happened.\n   * @param scrollPosition Object that is keeping track of the scroll position.\n   * @param newTop New top scroll position.\n   * @param newLeft New left scroll position.\n   * @param extraClientRect Extra `ClientRect` object that should be updated, in addition to the\n   *  ones of the drag items. Useful when the viewport has been scrolled and we also need to update\n   *  the `ClientRect` of the list.\n   */\n  private _updateAfterScroll(scrollPosition: ScrollPosition, newTop: number, newLeft: number,\n    extraClientRect?: ClientRect) {\n    const topDifference = scrollPosition.top - newTop;\n    const leftDifference = scrollPosition.left - newLeft;\n\n    if (extraClientRect) {\n      adjustClientRect(extraClientRect, topDifference, leftDifference);\n    }\n\n    // Since we know the amount that the user has scrolled we can shift all of the client rectangles\n    // ourselves. This is cheaper than re-measuring everything and we can avoid inconsistent\n    // behavior where we might be measuring the element before its position has changed.\n    this._itemPositions.forEach(({clientRect}) => {\n      adjustClientRect(clientRect, topDifference, leftDifference);\n    });\n\n    // We need two loops for this, because we want all of the cached\n    // positions to be up-to-date before we re-sort the item.\n    this._itemPositions.forEach(({drag}) => {\n      if (this._dragDropRegistry.isDragging(drag)) {\n        // We need to re-sort the item manually, because the pointer move\n        // events won't be dispatched while the user is scrolling.\n        drag._sortFromLastPointerPosition();\n      }\n    });\n\n    scrollPosition.top = newTop;\n    scrollPosition.left = newLeft;\n  }\n\n  /** Handles the container being scrolled. Has to be an arrow function to preserve the context. */\n  private _handleScroll = () => {\n    if (!this.isDragging()) {\n      return;\n    }\n\n    const element = coerceElement(this.element);\n    this._updateAfterScroll(this._scrollPosition, element.scrollTop, element.scrollLeft);\n  }\n\n  /** Removes the event listeners associated with this drop list. */\n  private _removeListeners() {\n    coerceElement(this.element).removeEventListener('scroll', this._handleScroll);\n    this._viewportScrollSubscription.unsubscribe();\n  }\n\n  /** Starts the interval that'll auto-scroll the element. */\n  private _startScrollInterval = () => {\n    this._stopScrolling();\n\n    interval(0, animationFrameScheduler)\n      .pipe(takeUntil(this._stopScrollTimers))\n      .subscribe(() => {\n        const node = this._scrollNode;\n\n        if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {\n          incrementVerticalScroll(node, -AUTO_SCROLL_STEP);\n        } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {\n          incrementVerticalScroll(node, AUTO_SCROLL_STEP);\n        }\n\n        if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {\n          incrementHorizontalScroll(node, -AUTO_SCROLL_STEP);\n        } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {\n          incrementHorizontalScroll(node, AUTO_SCROLL_STEP);\n        }\n      });\n  }\n\n  /**\n   * Checks whether the user's pointer is positioned over the container.\n   * @param x Pointer position along the X axis.\n   * @param y Pointer position along the Y axis.\n   */\n  _isOverContainer(x: number, y: number): boolean {\n    return isInsideClientRect(this._clientRect, x, y);\n  }\n\n  /**\n   * Figures out whether an item should be moved into a sibling\n   * drop container, based on its current position.\n   * @param item Drag item that is being moved.\n   * @param x Position of the item along the X axis.\n   * @param y Position of the item along the Y axis.\n   */\n  _getSiblingContainerFromPosition(item: DragRef, x: number, y: number): DropListRef | undefined {\n    return this._siblings.find(sibling => sibling._canReceive(item, x, y));\n  }\n\n  /**\n   * Checks whether the drop list can receive the passed-in item.\n   * @param item Item that is being dragged into the list.\n   * @param x Position of the item along the X axis.\n   * @param y Position of the item along the Y axis.\n   */\n  _canReceive(item: DragRef, x: number, y: number): boolean {\n    if (!this.enterPredicate(item, this) || !isInsideClientRect(this._clientRect, x, y)) {\n      return false;\n    }\n\n    const elementFromPoint = this._shadowRoot.elementFromPoint(x, y) as HTMLElement | null;\n\n    // If there's no element at the pointer position, then\n    // the client rect is probably scrolled out of the view.\n    if (!elementFromPoint) {\n      return false;\n    }\n\n    const nativeElement = coerceElement(this.element);\n\n    // The `ClientRect`, that we're using to find the container over which the user is\n    // hovering, doesn't give us any information on whether the element has been scrolled\n    // out of the view or whether it's overlapping with other containers. This means that\n    // we could end up transferring the item into a container that's invisible or is positioned\n    // below another one. We use the result from `elementFromPoint` to get the top-most element\n    // at the pointer position and to find whether it's one of the intersecting drop containers.\n    return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);\n  }\n\n  /**\n   * Called by one of the connected drop lists when a dragging sequence has started.\n   * @param sibling Sibling in which dragging has started.\n   */\n  _startReceiving(sibling: DropListRef) {\n    const activeSiblings = this._activeSiblings;\n\n    if (!activeSiblings.has(sibling)) {\n      activeSiblings.add(sibling);\n      this._cacheOwnPosition();\n      this._listenToScrollEvents();\n    }\n  }\n\n  /**\n   * Called by a connected drop list when dragging has stopped.\n   * @param sibling Sibling whose dragging has stopped.\n   */\n  _stopReceiving(sibling: DropListRef) {\n    this._activeSiblings.delete(sibling);\n    this._viewportScrollSubscription.unsubscribe();\n  }\n\n  /**\n   * Starts listening to scroll events on the viewport.\n   * Used for updating the internal state of the list.\n   */\n  private _listenToScrollEvents() {\n    this._viewportScrollPosition = this._viewportRuler!.getViewportScrollPosition();\n    this._viewportScrollSubscription = this._dragDropRegistry.scroll.subscribe(() => {\n      if (this.isDragging()) {\n        const newPosition = this._viewportRuler!.getViewportScrollPosition();\n        this._updateAfterScroll(this._viewportScrollPosition, newPosition.top, newPosition.left,\n                                this._clientRect);\n      } else if (this.isReceiving()) {\n        this._cacheOwnPosition();\n      }\n    });\n  }\n}\n\n\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param clientRect `ClientRect` that should be updated.\n * @param top Amount to add to the `top` position.\n * @param left Amount to add to the `left` position.\n */\nfunction adjustClientRect(clientRect: ClientRect, top: number, left: number) {\n  clientRect.top += top;\n  clientRect.bottom = clientRect.top + clientRect.height;\n\n  clientRect.left += left;\n  clientRect.right = clientRect.left + clientRect.width;\n}\n\n\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.findIndex` which isn't part of the standard Google typings.\n * @param array Array in which to look for matches.\n * @param predicate Function used to determine whether an item is a match.\n */\nfunction findIndex<T>(array: T[],\n                      predicate: (value: T, index: number, obj: T[]) => boolean): number {\n\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i], i, array)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param clientRect ClientRect that is being checked.\n * @param x Coordinates along the X axis.\n * @param y Coordinates along the Y axis.\n */\nfunction isInsideClientRect(clientRect: ClientRect, x: number, y: number) {\n  const {top, bottom, left, right} = clientRect;\n  return y >= top && y <= bottom && x >= left && x <= right;\n}\n\n\n/** Gets a mutable version of an element's bounding `ClientRect`. */\nfunction getMutableClientRect(element: Element): ClientRect {\n  const clientRect = element.getBoundingClientRect();\n\n  // We need to clone the `clientRect` here, because all the values on it are readonly\n  // and we need to be able to update them. Also we can't use a spread here, because\n  // the values on a `ClientRect` aren't own properties. See:\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n  return {\n    top: clientRect.top,\n    right: clientRect.right,\n    bottom: clientRect.bottom,\n    left: clientRect.left,\n    width: clientRect.width,\n    height: clientRect.height\n  };\n}\n\n/**\n * Increments the vertical scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementVerticalScroll(node: HTMLElement | Window, amount: number) {\n  if (node === window) {\n    (node as Window).scrollBy(0, amount);\n  } else {\n    // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n    (node as HTMLElement).scrollTop += amount;\n  }\n}\n\n/**\n * Increments the horizontal scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementHorizontalScroll(node: HTMLElement | Window, amount: number) {\n  if (node === window) {\n    (node as Window).scrollBy(amount, 0);\n  } else {\n    // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n    (node as HTMLElement).scrollLeft += amount;\n  }\n}\n\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getVerticalScrollDirection(clientRect: ClientRect, pointerY: number) {\n  const {top, bottom, height} = clientRect;\n  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n\n  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n    return AutoScrollVerticalDirection.UP;\n  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n    return AutoScrollVerticalDirection.DOWN;\n  }\n\n  return AutoScrollVerticalDirection.NONE;\n}\n\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerX Position of the user's pointer along the x axis.\n */\nfunction getHorizontalScrollDirection(clientRect: ClientRect, pointerX: number) {\n  const {left, right, width} = clientRect;\n  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n\n  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n    return AutoScrollHorizontalDirection.LEFT;\n  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n    return AutoScrollHorizontalDirection.RIGHT;\n  }\n\n  return AutoScrollHorizontalDirection.NONE;\n}\n\n/**\n * Gets the directions in which an element node should be scrolled,\n * assuming that the user's pointer is already within it scrollable region.\n * @param element Element for which we should calculate the scroll direction.\n * @param clientRect Bounding client rectangle of the element.\n * @param pointerX Position of the user's pointer along the x axis.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getElementScrollDirections(element: HTMLElement, clientRect: ClientRect, pointerX: number,\n  pointerY: number): [AutoScrollVerticalDirection, AutoScrollHorizontalDirection] {\n  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n\n  // Note that we here we do some extra checks for whether the element is actually scrollable in\n  // a certain direction and we only assign the scroll direction if it is. We do this so that we\n  // can allow other elements to be scrolled, if the current element can't be scrolled anymore.\n  // This allows us to handle cases where the scroll regions of two scrollable elements overlap.\n  if (computedVertical) {\n    const scrollTop = element.scrollTop;\n\n    if (computedVertical === AutoScrollVerticalDirection.UP) {\n      if (scrollTop > 0) {\n        verticalScrollDirection = AutoScrollVerticalDirection.UP;\n      }\n    } else if (element.scrollHeight - scrollTop > element.clientHeight) {\n      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;\n    }\n  }\n\n  if (computedHorizontal) {\n    const scrollLeft = element.scrollLeft;\n\n    if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {\n      if (scrollLeft > 0) {\n        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;\n      }\n    } else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n      horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;\n    }\n  }\n\n  return [verticalScrollDirection, horizontalScrollDirection];\n}\n\n/** Gets the shadow root of an element, if any. */\nfunction getShadowRoot(element: HTMLElement): DocumentOrShadowRoot | null {\n  if (_supportsShadowDom()) {\n    const rootNode = element.getRootNode ? element.getRootNode() : null;\n\n    if (rootNode instanceof ShadowRoot) {\n      return rootNode;\n    }\n  }\n\n  return null;\n}\n"]}
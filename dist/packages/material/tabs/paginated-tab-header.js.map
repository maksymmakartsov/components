{"version":3,"file":"paginated-tab-header.js","sourceRoot":"","sources":["../../../../src/material/tabs/paginated-tab-header.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ChangeDetectorRef,\n  ElementRef,\n  NgZone,\n  Optional,\n  QueryList,\n  EventEmitter,\n  AfterContentChecked,\n  AfterContentInit,\n  AfterViewInit,\n  OnDestroy,\n  Directive,\n  Inject,\n} from '@angular/core';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {FocusKeyManager, FocusableOption} from '@angular/cdk/a11y';\nimport {END, ENTER, HOME, SPACE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {merge, of as observableOf, Subject, timer, fromEvent} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\n\n/** Config used to bind passive event listeners */\nconst passiveEventListenerOptions =\n    normalizePassiveListenerOptions({passive: true}) as EventListenerOptions;\n\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport type ScrollDirection = 'after' | 'before';\n\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n\n/**\n * Amount of milliseconds to wait before starting to scroll the header automatically.\n * Set a little conservatively in order to handle fake events dispatched on touch devices.\n */\nconst HEADER_SCROLL_DELAY = 650;\n\n/**\n * Interval in milliseconds at which to scroll the header\n * while the user is holding their pointer.\n */\nconst HEADER_SCROLL_INTERVAL = 100;\n\n/** Item inside a paginated tab header. */\nexport type MatPaginatedTabHeaderItem = FocusableOption & {elementRef: ElementRef};\n\n/**\n * Base class for a tab header that supported pagination.\n * @docs-private\n */\n@Directive({\n  // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.\n  selector: 'do-not-use-abstract-mat-paginated-tab-header'\n})\nexport abstract class MatPaginatedTabHeader implements AfterContentChecked, AfterContentInit,\n  AfterViewInit, OnDestroy {\n  abstract _items: QueryList<MatPaginatedTabHeaderItem>;\n  abstract _inkBar: {hide: () => void, alignToElement: (element: HTMLElement) => void};\n  abstract _tabListContainer: ElementRef<HTMLElement>;\n  abstract _tabList: ElementRef<HTMLElement>;\n  abstract _nextPaginator: ElementRef<HTMLElement>;\n  abstract _previousPaginator: ElementRef<HTMLElement>;\n\n  /** The distance in pixels that the tab labels should be translated to the left. */\n  private _scrollDistance = 0;\n\n  /** Whether the header should scroll to the selected index after the view has been checked. */\n  private _selectedIndexChanged = false;\n\n  /** Emits when the component is destroyed. */\n  protected readonly _destroyed = new Subject<void>();\n\n  /** Whether the controls for pagination should be displayed */\n  _showPaginationControls = false;\n\n  /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n  _disableScrollAfter = true;\n\n  /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n  _disableScrollBefore = true;\n\n  /**\n   * The number of tab labels that are displayed on the header. When this changes, the header\n   * should re-evaluate the scroll position.\n   */\n  private _tabLabelCount: number;\n\n  /** Whether the scroll distance has changed and should be applied after the view is checked. */\n  private _scrollDistanceChanged: boolean;\n\n  /** Used to manage focus between the tabs. */\n  private _keyManager: FocusKeyManager<MatPaginatedTabHeaderItem>;\n\n  /** Cached text content of the header. */\n  private _currentTextContent: string;\n\n  /** Stream that will stop the automated scrolling. */\n  private _stopScrolling = new Subject<void>();\n\n  /** The index of the active tab. */\n  get selectedIndex(): number { return this._selectedIndex; }\n  set selectedIndex(value: number) {\n    value = coerceNumberProperty(value);\n\n    if (this._selectedIndex != value) {\n      this._selectedIndexChanged = true;\n      this._selectedIndex = value;\n\n      if (this._keyManager) {\n        this._keyManager.updateActiveItemIndex(value);\n      }\n    }\n  }\n  private _selectedIndex: number = 0;\n\n  /** Event emitted when the option is selected. */\n  readonly selectFocusedIndex: EventEmitter<number> = new EventEmitter<number>();\n\n  /** Event emitted when a label is focused. */\n  readonly indexFocused: EventEmitter<number> = new EventEmitter<number>();\n\n  constructor(protected _elementRef: ElementRef<HTMLElement>,\n              protected _changeDetectorRef: ChangeDetectorRef,\n              private _viewportRuler: ViewportRuler,\n              @Optional() private _dir: Directionality,\n              private _ngZone: NgZone,\n              /**\n               * @deprecated @breaking-change 9.0.0 `_platform` and `_animationMode`\n               * parameters to become required.\n               */\n              private _platform?: Platform,\n              @Optional() @Inject(ANIMATION_MODULE_TYPE) public _animationMode?: string) {\n\n    // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n    _ngZone.runOutsideAngular(() => {\n      fromEvent(_elementRef.nativeElement, 'mouseleave')\n        .pipe(takeUntil(this._destroyed))\n        .subscribe(() => {\n          this._stopInterval();\n        });\n    });\n  }\n\n  /** Called when the user has selected an item via the keyboard. */\n  protected abstract _itemSelected(event: KeyboardEvent): void;\n\n  ngAfterViewInit() {\n    // We need to handle these events manually, because we want to bind passive event listeners.\n    fromEvent(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => {\n        this._handlePaginatorPress('before');\n      });\n\n    fromEvent(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => {\n        this._handlePaginatorPress('after');\n      });\n  }\n\n  ngAfterContentInit() {\n    const dirChange = this._dir ? this._dir.change : observableOf(null);\n    const resize = this._viewportRuler.change(150);\n    const realign = () => {\n      this.updatePagination();\n      this._alignInkBarToSelectedTab();\n    };\n\n    this._keyManager = new FocusKeyManager<MatPaginatedTabHeaderItem>(this._items)\n      .withHorizontalOrientation(this._getLayoutDirection())\n      .withWrap();\n\n    this._keyManager.updateActiveItem(0);\n\n    // Defer the first call in order to allow for slower browsers to lay out the elements.\n    // This helps in cases where the user lands directly on a page with paginated tabs.\n    typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n\n    // On dir change or window resize, realign the ink bar and update the orientation of\n    // the key manager if the direction has changed.\n    merge(dirChange, resize, this._items.changes).pipe(takeUntil(this._destroyed)).subscribe(() => {\n      realign();\n      this._keyManager.withHorizontalOrientation(this._getLayoutDirection());\n    });\n\n    // If there is a change in the focus key manager we need to emit the `indexFocused`\n    // event in order to provide a public event that notifies about focus changes. Also we realign\n    // the tabs container by scrolling the new focused tab into the visible section.\n    this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe(newFocusIndex => {\n      this.indexFocused.emit(newFocusIndex);\n      this._setTabFocus(newFocusIndex);\n    });\n  }\n\n  ngAfterContentChecked(): void {\n    // If the number of tab labels have changed, check if scrolling should be enabled\n    if (this._tabLabelCount != this._items.length) {\n      this.updatePagination();\n      this._tabLabelCount = this._items.length;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // If the selected index has changed, scroll to the label and check if the scrolling controls\n    // should be disabled.\n    if (this._selectedIndexChanged) {\n      this._scrollToLabel(this._selectedIndex);\n      this._checkScrollingControls();\n      this._alignInkBarToSelectedTab();\n      this._selectedIndexChanged = false;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n    // then translate the header to reflect this.\n    if (this._scrollDistanceChanged) {\n      this._updateTabScrollPosition();\n      this._scrollDistanceChanged = false;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n    this._stopScrolling.complete();\n  }\n\n  /** Handles keyboard events on the header. */\n  _handleKeydown(event: KeyboardEvent) {\n    // We don't handle any key bindings with a modifier key.\n    if (hasModifierKey(event)) {\n      return;\n    }\n\n    switch (event.keyCode) {\n      case HOME:\n        this._keyManager.setFirstItemActive();\n        event.preventDefault();\n        break;\n      case END:\n        this._keyManager.setLastItemActive();\n        event.preventDefault();\n        break;\n      case ENTER:\n      case SPACE:\n        this.selectFocusedIndex.emit(this.focusIndex);\n        this._itemSelected(event);\n        break;\n      default:\n        this._keyManager.onKeydown(event);\n    }\n  }\n\n  /**\n   * Callback for when the MutationObserver detects that the content has changed.\n   */\n  _onContentChanges() {\n    const textContent = this._elementRef.nativeElement.textContent;\n\n    // We need to diff the text content of the header, because the MutationObserver callback\n    // will fire even if the text content didn't change which is inefficient and is prone\n    // to infinite loops if a poorly constructed expression is passed in (see #14249).\n    if (textContent !== this._currentTextContent) {\n      this._currentTextContent = textContent || '';\n\n      // The content observer runs outside the `NgZone` by default, which\n      // means that we need to bring the callback back in ourselves.\n      this._ngZone.run(() => {\n        this.updatePagination();\n        this._alignInkBarToSelectedTab();\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n  }\n\n  /**\n   * Updates the view whether pagination should be enabled or not.\n   *\n   * WARNING: Calling this method can be very costly in terms of performance. It should be called\n   * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n   * page.\n   */\n  updatePagination() {\n    this._checkPaginationEnabled();\n    this._checkScrollingControls();\n    this._updateTabScrollPosition();\n  }\n\n  /** Tracks which element has focus; used for keyboard navigation */\n  get focusIndex(): number {\n    return this._keyManager ? this._keyManager.activeItemIndex! : 0;\n  }\n\n  /** When the focus index is set, we must manually send focus to the correct label */\n  set focusIndex(value: number) {\n    if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n      return;\n    }\n\n    this._keyManager.setActiveItem(value);\n  }\n\n  /**\n   * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n   * providing a valid index and return true.\n   */\n  _isValidIndex(index: number): boolean {\n    if (!this._items) { return true; }\n\n    const tab = this._items ? this._items.toArray()[index] : null;\n    return !!tab && !tab.disabled;\n  }\n\n  /**\n   * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n   * scrolling is enabled.\n   */\n  _setTabFocus(tabIndex: number) {\n    if (this._showPaginationControls) {\n      this._scrollToLabel(tabIndex);\n    }\n\n    if (this._items && this._items.length) {\n      this._items.toArray()[tabIndex].focus();\n\n      // Do not let the browser manage scrolling to focus the element, this will be handled\n      // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n      // should be the full width minus the offset width.\n      const containerEl = this._tabListContainer.nativeElement;\n      const dir = this._getLayoutDirection();\n\n      if (dir == 'ltr') {\n        containerEl.scrollLeft = 0;\n      } else {\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n      }\n    }\n  }\n\n  /** The layout direction of the containing app. */\n  _getLayoutDirection(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n  _updateTabScrollPosition() {\n    const scrollDistance = this.scrollDistance;\n    const platform = this._platform;\n    const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n\n    // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n    // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n    // and ripples will exceed the boundaries of the visible tab bar.\n    // See: https://github.com/angular/components/issues/10276\n    // We round the `transform` here, because transforms with sub-pixel precision cause some\n    // browsers to blur the content of the element.\n    this._tabList.nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`;\n\n    // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n    // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n    // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n    // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n    // @breaking-change 9.0.0 Remove null check for `platform` after it can no longer be undefined.\n    if (platform && (platform.TRIDENT || platform.EDGE)) {\n      this._tabListContainer.nativeElement.scrollLeft = 0;\n    }\n  }\n\n  /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n  get scrollDistance(): number { return this._scrollDistance; }\n  set scrollDistance(value: number) {\n    this._scrollTo(value);\n  }\n\n  /**\n   * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n   * the end of the list, respectively). The distance to scroll is computed to be a third of the\n   * length of the tab list view window.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _scrollHeader(direction: ScrollDirection) {\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    // Move the scroll distance one-third the length of the tab list's viewport.\n    const scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;\n\n    return this._scrollTo(this._scrollDistance + scrollAmount);\n  }\n\n  /** Handles click events on the pagination arrows. */\n  _handlePaginatorClick(direction: ScrollDirection) {\n    this._stopInterval();\n    this._scrollHeader(direction);\n  }\n\n  /**\n   * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _scrollToLabel(labelIndex: number) {\n    const selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;\n\n    if (!selectedLabel) { return; }\n\n    // The view length is the visible width of the tab labels.\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    const {offsetLeft, offsetWidth} = selectedLabel.elementRef.nativeElement;\n\n    let labelBeforePos: number, labelAfterPos: number;\n    if (this._getLayoutDirection() == 'ltr') {\n      labelBeforePos = offsetLeft;\n      labelAfterPos = labelBeforePos + offsetWidth;\n    } else {\n      labelAfterPos = this._tabList.nativeElement.offsetWidth - offsetLeft;\n      labelBeforePos = labelAfterPos - offsetWidth;\n    }\n\n    const beforeVisiblePos = this.scrollDistance;\n    const afterVisiblePos = this.scrollDistance + viewLength;\n\n    if (labelBeforePos < beforeVisiblePos) {\n      // Scroll header to move label to the before direction\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n    } else if (labelAfterPos > afterVisiblePos) {\n      // Scroll header to move label to the after direction\n      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n    }\n  }\n\n  /**\n   * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n   * tab list is wider than the size of the header container, then the pagination controls should\n   * be shown.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _checkPaginationEnabled() {\n    const isEnabled =\n        this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n    if (!isEnabled) {\n      this.scrollDistance = 0;\n    }\n\n    if (isEnabled !== this._showPaginationControls) {\n      this._changeDetectorRef.markForCheck();\n    }\n\n    this._showPaginationControls = isEnabled;\n  }\n\n  /**\n   * Evaluate whether the before and after controls should be enabled or disabled.\n   * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n   * before button. If the header is at the end of the list (scroll distance is equal to the\n   * maximum distance we can scroll), then disable the after button.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _checkScrollingControls() {\n    // Check if the pagination arrows should be activated.\n    this._disableScrollBefore = this.scrollDistance == 0;\n    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n   * is equal to the difference in width between the tab list container and tab header container.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _getMaxScrollDistance(): number {\n    const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    return (lengthOfTabList - viewLength) || 0;\n  }\n\n  /** Tells the ink-bar to align itself to the current label wrapper */\n  _alignInkBarToSelectedTab(): void {\n    const selectedItem = this._items && this._items.length ?\n        this._items.toArray()[this.selectedIndex] : null;\n    const selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;\n\n    if (selectedLabelWrapper) {\n      this._inkBar.alignToElement(selectedLabelWrapper);\n    } else {\n      this._inkBar.hide();\n    }\n  }\n\n  /** Stops the currently-running paginator interval.  */\n  _stopInterval() {\n    this._stopScrolling.next();\n  }\n\n  /**\n   * Handles the user pressing down on one of the paginators.\n   * Starts scrolling the header after a certain amount of time.\n   * @param direction In which direction the paginator should be scrolled.\n   */\n  _handlePaginatorPress(direction: ScrollDirection) {\n    // Avoid overlapping timers.\n    this._stopInterval();\n\n    // Start a timer after the delay and keep firing based on the interval.\n    timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n      // Keep the timer going until something tells it to stop or the component is destroyed.\n      .pipe(takeUntil(merge(this._stopScrolling, this._destroyed)))\n      .subscribe(() => {\n        const {maxScrollDistance, distance} = this._scrollHeader(direction);\n\n        // Stop the timer if we've reached the start or the end.\n        if (distance === 0 || distance >= maxScrollDistance) {\n          this._stopInterval();\n        }\n      });\n  }\n\n  /**\n   * Scrolls the header to a given position.\n   * @param position Position to which to scroll.\n   * @returns Information on the current scroll distance and the maximum.\n   */\n  private _scrollTo(position: number) {\n    const maxScrollDistance = this._getMaxScrollDistance();\n    this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n\n    // Mark that the scroll distance has changed so that after the view is checked, the CSS\n    // transformation can move the header.\n    this._scrollDistanceChanged = true;\n    this._checkScrollingControls();\n\n    return {maxScrollDistance, distance: this._scrollDistance};\n  }\n}\n"]}